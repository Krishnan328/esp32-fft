<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>ESP32 FFT Spectrum Analyzer</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				margin: 0;
				padding: 0;
				height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				background-color: #222;
				color: #eee;
			}
			.container {
				width: 90vw;
				height: 90vh;
				display: grid;
				grid-template-rows: auto 1fr auto;
				gap: 10px;
				overflow: hidden;
			}
			h1 {
				color: #4caf50;
				text-align: center;
			}
			canvas {
				flex: 3;
				width: 100%;
				height: 100%;
				background-color: #000;
				border-radius: 5px;
			}
			.info {
				display: flex;
				justify-content: space-between;
				width: 100%;
			}
			.info div {
				background-color: #333;
				padding: 10px;
				border-radius: 5px;
				flex: 1;
				margin: 0 5px;
				text-align: center;
			}
			.info span {
				font-size: 24px;
				color: #4caf50;
				display: block;
				margin-top: 5px;
			}
			/* Add to the style section */
			.main-content {
				display: flex;
				height: 100%;
				gap: 10px;
				overflow: hidden;
			}

			/* canvas {
                flex: 3;
                height: 100%;
                background-color: #000;
                border-radius: 5px;
            } */

			.log-window {
				flex: 1;
				height: 100%;
				background-color: #111;
				border-radius: 5px;
				padding: 10px;
				overflow: hidden;
				display: flex;
				flex-direction: column;
			}

			.log-window h3 {
				margin-top: 0;
				color: #4caf50;
				text-align: center;
				border-bottom: 1px solid #333;
				padding-bottom: 5px;
			}

			#impulseLog {
				overflow-y: auto;
				flex-grow: 1;
				font-family: monospace;
				font-size: 12px;
			}

			.impulse-entry {
				margin-bottom: 10px;
				padding: 5px;
				background-color: #222;
				border-left: 3px solid #4caf50;
			}

			.impulse-time {
				color: #aaa;
				font-size: 10px;
			}

			.impulse-freq {
				color: #4caf50;
				font-weight: bold;
			}

			.impulse-data {
				display: block;
				margin-top: 3px;
				color: #ddd;
				word-break: break-all;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>ESP32 FFT Spectrum Analyzer</h1>
			<div class="main-content">
				<canvas id="fftCanvas"></canvas>
				<div class="log-window">
					<h3>Impulse Log</h3>
					<div id="impulseLog"></div>
				</div>
			</div>
			<div class="info">
				<div>
					Dominant Frequency
					<span id="dominantFreq">0 Hz</span>
				</div>
				<div>
					Update Rate
					<span id="updateRate">0 fps</span>
				</div>
				<div>
					Last Impulse
					<span id="lastImpulse">None</span>
				</div>
				<div>
					Coconut Type
					<span id="coconutType">Unknown</span>
				</div>
			</div>
		</div>

		<script>
			const canvas = document.getElementById("fftCanvas");
			const ctx = canvas.getContext("2d");
			const dominantFreqElem = document.getElementById("dominantFreq");
			const updateRateElem = document.getElementById("updateRate");

			// Variables for FPS calculation
			let frameCount = 0;
			let lastFpsUpdateTime = 0;

			// Variables to adjust the audio sampling rate and FFT Bin size
			const SAMPLING_RATE = 48000; // Change this value in constants.rs too!
			const FFT_LENGTH = 2048; // Change this value in constants.rs too!
			const FREQUENCY_MAGNITUDE_LENGHT = FFT_LENGTH / 2; // Change this value in constants.rs too!

			// Audio frequency range
			const minFreq = 20; // 20 Hz
			const maxFreq = 22000; // 20 kHz

			let prevMagnitudeSum = 0;
			const impulseThreshold = 0.5; // Adjust based on your signal
			const impulseTimeThreshold = 100; // Minimum time between impulses in ms
			let lastImpulseTime = 0;
			const impulseLogElement = document.getElementById("impulseLog");
			const lastImpulseElement = document.getElementById("lastImpulse");
			const coconutTypeElement = document.getElementById("coconutType");
			const maxLogEntries = 50; // Maximum number of log entries to show

			// Resize canvas to match display size
			function resizeCanvas() {
				canvas.width = canvas.offsetWidth;
				canvas.height = canvas.offsetHeight;
				drawFrequencyScale();
			}

			// Initial resize
			resizeCanvas();

			// Update canvas on window resize
			window.addEventListener("resize", resizeCanvas);

			// Function to draw logarithmic frequency scale
			function drawFrequencyScale() {
				const width = canvas.width;
				const height = canvas.height;

				ctx.fillStyle = "#000";
				ctx.fillRect(0, 0, width, height);

				// Draw grid lines
				ctx.strokeStyle = "#333";
				ctx.lineWidth = 1;

				// Horizontal grid lines (amplitude)
				for (let i = 0; i < 10; i++) {
					const y = height - (i * height) / 10;
					ctx.beginPath();
					ctx.moveTo(0, y);
					ctx.lineTo(width, y);
					ctx.stroke();
				}

				// Vertical grid lines (frequency - logarithmic)
				const decades = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 22000];
				ctx.fillStyle = "#FFFFFF";
				ctx.font = "14px Arial";

				decades.forEach((freq) => {
					const x =
						(width * (Math.log10(freq) - Math.log10(minFreq))) /
						(Math.log10(maxFreq) - Math.log10(minFreq));

					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x, height);
					ctx.stroke();

					// Add frequency label
					let label = freq.toString();
					if (freq >= 1000) {
						label = freq / 1000 + "k";
					}
					const textWidth = ctx.measureText(label).width;
					if (x - textWidth / 2 < 0) {
						ctx.textAlign = "left";
					} else if (x + textWidth / 2 > width) {
						ctx.textAlign = "right";
					} else {
						ctx.textAlign = "center";
					}
					ctx.fillText(label, x, height - 5);
				});
			}

			// Function to update the spectrum visualization
			function updateSpectrum(magnitudes, dominantFrequency) {
				const width = canvas.width;
				const height = canvas.height;

				// Clear and redraw the background
				drawFrequencyScale();

				// Smooth the magnitudes with a moving average
				let smoothed_magnitudes = [];
				for (let i = 0; i < magnitudes.length; i++) {
					if (i === 0) {
						smoothed_magnitudes[i] = (magnitudes[i] + magnitudes[i + 1]) / 2;
					} else if (i === magnitudes.length - 1) {
						smoothed_magnitudes[i] = (magnitudes[i - 1] + magnitudes[i]) / 2;
					} else {
						smoothed_magnitudes[i] =
							(magnitudes[i - 1] + magnitudes[i] + magnitudes[i + 1]) / 3;
					}
				}

				// Draw the spectrum
				ctx.beginPath();
				ctx.moveTo(0, height);

				for (let i = 1; i < smoothed_magnitudes.length; i++) {
					const frequency = i * (SAMPLING_RATE / FFT_LENGTH);
					if (frequency < minFreq || frequency > maxFreq) continue;
					const x =
						(width * (Math.log10(frequency) - Math.log10(minFreq))) /
						(Math.log10(maxFreq) - Math.log10(minFreq));
					const magnitude = Math.max(0.0000001, smoothed_magnitudes[i]);
					const dB = 20 * Math.log10(magnitude);
					const normalizedDb = (dB + 100) / 100; // Normalize to 0-1 (assuming -100dB to 0dB range)
					const y = height - normalizedDb * height;
					ctx.lineTo(x, y);
				}

				ctx.lineTo(width, height);
				ctx.closePath();

				// Fill the spectrum area with gradient
				const gradient = ctx.createLinearGradient(0, 0, 0, height);
				gradient.addColorStop(0, "rgba(76, 175, 80, 0.8)");
				gradient.addColorStop(1, "rgba(76, 175, 80, 0.1)");
				ctx.fillStyle = gradient;
				ctx.fill();

				// Update dominant frequency display
				dominantFreqElem.textContent = dominantFrequency.toFixed(1) + " Hz";

				// Update FPS counter
				frameCount++;
				const now = performance.now();
				if (now - lastFpsUpdateTime > 1000) {
					const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdateTime));
					updateRateElem.textContent = fps + " fps";
					frameCount = 0;
					lastFpsUpdateTime = now;
				}
			}

			// Establish WebSocket connection
			const ws = new WebSocket("ws://192.168.71.1/ws");

			ws.onopen = function () {
				console.log("WebSocket connection established");
			};

			ws.onmessage = function (event) {
				if (event.data instanceof ArrayBuffer) {
					const buffer = event.data;
					const dataView = new DataView(buffer);

					// Check the header byte to determine the message type
					const messageType = dataView.getUint8(0);

					if (messageType === 0x01) {
						// FFT data
						const floatArray = new Float32Array(
							buffer.slice(1),
							0,
							FREQUENCY_MAGNITUDE_LENGHT,
						);
						const dominantFreq = new Float32Array(
							buffer.slice(1 + FREQUENCY_MAGNITUDE_LENGHT * 4),
							0,
							1,
						)[0];
						updateSpectrum(floatArray, dominantFreq);
					} else if (messageType === 0x02) {
						// Impulse data
						let offset = 1; // Skip header byte

						// Extract timestamp (8 bytes)
						const timestamp =
							dataView.getUint32(offset, true) +
							dataView.getUint32(offset + 4, true) * 4294967296; // Handle 64-bit
						offset += 8;

						// Extract dominant frequency (4 bytes)
						const dominantFrequency = dataView.getFloat32(offset, true);
						offset += 4;

						// Extract peak count (1 byte)
						const peakCount = dataView.getUint8(offset);
						offset += 1;

						// Extract peaks
						const peaks = [];
						for (let i = 0; i < peakCount; i++) {
							const index = dataView.getUint16(offset, true);
							offset += 2;

							const frequency = dataView.getFloat32(offset, true);
							offset += 4;

							const magnitude = dataView.getFloat32(offset, true);
							offset += 4;

							peaks.push({ index, frequency, magnitude });
						}

						// Extract coconut type string
						const coconutTypeLength = dataView.getUint8(offset);
						offset += 1;

						const coconutTypeBytes = new Uint8Array(
							buffer.slice(offset, offset + coconutTypeLength),
						);
						const coconutType = new TextDecoder().decode(coconutTypeBytes);

						// Process impulse data
						const date = new Date();
						const formattedTimestamp = date.toLocaleTimeString();

						const peaksFormatted = peaks
							.map(
								(peak) =>
									`${peak.frequency.toFixed(1)} Hz (${peak.magnitude.toFixed(4)})`,
							)
							.join(", ");

						// Update the coconut type
						if (coconutType) {
							coconutTypeElement.textContent = coconutType;
						}

						const entry = document.createElement("div");
						entry.className = "impulse-entry";
						entry.innerHTML = `
                <div class="impulse-time">${formattedTimestamp}</div>
                <div class="impulse-freq">Dominant: ${dominantFrequency.toFixed(1)} Hz</div>
                <div class="impulse-data">Peaks: ${peaksFormatted}</div>
                <div class="impulse-data">Type: ${coconutType || "Unknown"}</div>
            `;

						impulseLogElement.prepend(entry);
						while (impulseLogElement.children.length > maxLogEntries) {
							impulseLogElement.removeChild(impulseLogElement.lastChild);
						}
						lastImpulseElement.textContent = formattedTimestamp;
					}
				} else if (event.data instanceof Blob) {
					// Handle binary data that comes as Blob
					event.data.arrayBuffer().then((buffer) => {
						const dataView = new DataView(buffer);
						const messageType = dataView.getUint8(0);

						if (messageType === 0x01) {
							// FFT data
							const floatArray = new Float32Array(
								buffer.slice(1),
								0,
								FREQUENCY_MAGNITUDE_LENGHT,
							);
							const dominantFreq = new Float32Array(
								buffer.slice(1 + FREQUENCY_MAGNITUDE_LENGHT * 4),
								0,
								1,
							)[0];
							updateSpectrum(floatArray, dominantFreq);
						} else if (messageType === 0x02) {
							// Process impulse data
							let offset = 1; // Skip header byte

							// Extract timestamp (8 bytes)
							const timestamp =
								dataView.getUint32(offset, true) +
								dataView.getUint32(offset + 4, true) * 4294967296; // Handle 64-bit
							offset += 8;

							// Extract dominant frequency (4 bytes)
							const dominantFrequency = dataView.getFloat32(offset, true);
							offset += 4;

							// Extract peak count (1 byte)
							const peakCount = dataView.getUint8(offset);
							offset += 1;

							// Extract peaks
							const peaks = [];
							for (let i = 0; i < peakCount; i++) {
								const index = dataView.getUint16(offset, true);
								offset += 2;

								const frequency = dataView.getFloat32(offset, true);
								offset += 4;

								const magnitude = dataView.getFloat32(offset, true);
								offset += 4;

								peaks.push({ index, frequency, magnitude });
							}

							// Extract coconut type string
							const coconutTypeLength = dataView.getUint8(offset);
							offset += 1;

							const coconutTypeBytes = new Uint8Array(
								buffer.slice(offset, offset + coconutTypeLength),
							);
							const coconutType = new TextDecoder().decode(coconutTypeBytes);

							// Process impulse data
							const date = new Date();
							const formattedTimestamp = date.toLocaleTimeString();

							const peaksFormatted = peaks
								.map(
									(peak) =>
										`${peak.frequency.toFixed(1)} Hz (${peak.magnitude.toFixed(4)})`,
								)
								.join(", ");

							// Update the coconut type
							if (coconutType) {
								coconutTypeElement.textContent = coconutType;
							}

							const entry = document.createElement("div");
							entry.className = "impulse-entry";
							entry.innerHTML = `
                    <div class="impulse-time">${formattedTimestamp}</div>
                    <div class="impulse-freq">Dominant: ${dominantFrequency.toFixed(1)} Hz</div>
                    <div class="impulse-data">Peaks: ${peaksFormatted}</div>
                    <div class="impulse-data">Type: ${coconutType || "Unknown"}</div>
                `;

							impulseLogElement.prepend(entry);
							while (impulseLogElement.children.length > maxLogEntries) {
								impulseLogElement.removeChild(impulseLogElement.lastChild);
							}
							lastImpulseElement.textContent = formattedTimestamp;
						}
					});
				}
			};

			ws.onerror = function (error) {
				console.error("WebSocket error:", error);
			};

			ws.onclose = function () {
				console.log("WebSocket connection closed");
			};
		</script>
	</body>
</html>
